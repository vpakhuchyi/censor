"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[626],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},9463:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"supported-types","title":"Supported Types","description":"Censor supports a wide range of Go types and handles them recursively when possible. Here\'s a detailed overview of how different types are processed.","source":"@site/docs/supported-types.md","sourceDirName":".","slug":"/supported-types","permalink":"/censor/supported-types","draft":false,"unlisted":false,"editUrl":"https://github.com/vpakhuchyi/censor-doc/tree/main/docs/supported-types.md","tags":[],"version":"current","lastUpdatedBy":"Viktor","lastUpdatedAt":1743860759000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5}}');var r=t(4848),i=t(8453);const a={sidebar_position:5},l="Supported Types",o={},c=[{value:"Structs",id:"structs",level:2},{value:"Maps",id:"maps",level:2},{value:"Map Type Display",id:"map-type-display",level:3},{value:"Slices and Arrays",id:"slices-and-arrays",level:2},{value:"Pointers",id:"pointers",level:2},{value:"Basic Types",id:"basic-types",level:2},{value:"Strings",id:"strings",level:3},{value:"Numbers",id:"numbers",level:3},{value:"Booleans",id:"booleans",level:3},{value:"Custom Types",id:"custom-types",level:2},{value:"TextMarshaler Interface",id:"textmarshaler-interface",level:3},{value:"Interface Values",id:"interface-values",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"supported-types",children:"Supported Types"})}),"\n",(0,r.jsx)(n.p,{children:"Censor supports a wide range of Go types and handles them recursively when possible. Here's a detailed overview of how different types are processed."}),"\n",(0,r.jsx)(n.h2,{id:"structs",children:"Structs"}),"\n",(0,r.jsxs)(n.p,{children:["By default, all struct fields are masked unless explicitly marked for display using the ",(0,r.jsx)(n.code,{children:'censor:"display"'})," tag."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'type User struct {\n    ID       string `censor:"display"` // Will be displayed\n    Name     string `censor:"display"` // Will be displayed\n    Email    string                    // Will be masked\n    Password string                    // Will be masked\n}\n\nuser := User{\n    ID:       "123",\n    Name:     "John Doe",\n    Email:    "john@example.com",\n    Password: "secret123",\n}\n\nfmt.Println(censor.Format(user))\n// Output: {ID: 123, Name: John Doe, Email: [CENSORED], Password: [CENSORED]}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Unexported fields are always ignored."]}),"\n",(0,r.jsx)(n.h2,{id:"maps",children:"Maps"}),"\n",(0,r.jsx)(n.p,{children:"Maps are processed recursively, with both keys and values being formatted according to their respective types."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Map with struct keys and slice values\ntype UserKey struct {\n    ID      string `censor:"display"`\n    Account string\n}\n\ndata := map[UserKey][]string{\n    {ID: "123", Account: "premium"}: {"email1@example.com", "email2@example.com"},\n    {ID: "456", Account: "basic"}:   {"email3@example.com"},\n}\n\nfmt.Println(censor.Format(data))\n// Output: map[{ID: 123, Account: [CENSORED]}: [[CENSORED], [CENSORED]], {ID: 456, Account: [CENSORED]}: [[CENSORED]]]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"map-type-display",children:"Map Type Display"}),"\n",(0,r.jsx)(n.p,{children:"You can enable map type display in the output:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'cfg := censor.Config{\n    Encoder: censor.EncoderConfig{\n        DisplayMapType: true,\n    },\n}\n\ndata := map[string]int{"one": 1, "two": 2}\nfmt.Println(censor.Format(data))\n// Output: map[string]int[one: 1, two: 2]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"slices-and-arrays",children:"Slices and Arrays"}),"\n",(0,r.jsx)(n.p,{children:"Slices and arrays are processed element by element, with each element formatted according to its type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Simple slice\nnumbers := []int{1, 2, 3}\nfmt.Println(censor.Format(numbers))\n// Output: [1, 2, 3]\n\n// Nested slices\nmatrix := [][]int{{1, 2}, {3, 4}}\nfmt.Println(censor.Format(matrix))\n// Output: [[1, 2], [3, 4]]\n\n// Slice of structs\nusers := []User{\n    {ID: "123", Email: "user1@example.com"},\n    {ID: "456", Email: "user2@example.com"},\n}\nfmt.Println(censor.Format(users))\n// Output: [{ID: 123, Email: [CENSORED]}, {ID: 456, Email: [CENSORED]}]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"pointers",children:"Pointers"}),"\n",(0,r.jsx)(n.p,{children:"Pointers are dereferenced and their underlying values are formatted according to the type rules:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Pointer to struct\nuser := &User{ID: "123", Email: "john@example.com"}\nfmt.Println(censor.Format(user))\n// Output: {ID: 123, Email: [CENSORED]}\n\n// Nil pointer\nvar nilUser *User\nfmt.Println(censor.Format(nilUser))\n// Output: nil\n'})}),"\n",(0,r.jsx)(n.h2,{id:"basic-types",children:"Basic Types"}),"\n",(0,r.jsx)(n.h3,{id:"strings",children:"Strings"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Plain string\ntext := "Hello, World!"\nfmt.Println(censor.Format(text))\n// Output: Hello, World!\n\n// String with sensitive pattern\nemail := "contact@example.com"\nfmt.Println(censor.Format(email)) // With email pattern configured\n// Output: [CENSORED]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"numbers",children:"Numbers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"// Integers\nfmt.Println(censor.Format(42))          // Output: 42\nfmt.Println(censor.Format(int64(999)))  // Output: 999\n\n// Floating point\nfmt.Println(censor.Format(3.14))        // Output: 3.14\nfmt.Println(censor.Format(float32(1.5))) // Output: 1.5\n"})}),"\n",(0,r.jsx)(n.h3,{id:"booleans",children:"Booleans"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"fmt.Println(censor.Format(true))   // Output: true\nfmt.Println(censor.Format(false))  // Output: false\n"})}),"\n",(0,r.jsx)(n.h2,{id:"custom-types",children:"Custom Types"}),"\n",(0,r.jsx)(n.h3,{id:"textmarshaler-interface",children:"TextMarshaler Interface"}),"\n",(0,r.jsxs)(n.p,{children:["Types implementing the ",(0,r.jsx)(n.code,{children:"encoding.TextMarshaler"})," interface are supported:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'type CustomID string\n\nfunc (id CustomID) MarshalText() ([]byte, error) {\n    return []byte(fmt.Sprintf("ID-%s", string(id))), nil\n}\n\nid := CustomID("123")\nfmt.Println(censor.Format(id))\n// Output: ID-123\n'})}),"\n",(0,r.jsx)(n.h2,{id:"interface-values",children:"Interface Values"}),"\n",(0,r.jsx)(n.p,{children:"Interface values are processed based on their concrete type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'var data interface{} = User{ID: "123", Email: "john@example.com"}\nfmt.Println(censor.Format(data))\n// Output: {ID: 123, Email: [CENSORED]}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Use the ",(0,r.jsx)(n.code,{children:'censor:"display"'})," tag judiciously to control what information is visible"]}),"\n",(0,r.jsxs)(n.li,{children:["Consider implementing ",(0,r.jsx)(n.code,{children:"encoding.TextMarshaler"})," for custom types that need special formatting"]}),"\n",(0,r.jsx)(n.li,{children:"Be aware that unexported struct fields are ignored"}),"\n",(0,r.jsx)(n.li,{children:"Test the output format with different combinations of nested types"}),"\n",(0,r.jsxs)(n.li,{children:["Use configuration options like ",(0,r.jsx)(n.code,{children:"DisplayMapType"})," when additional type information is needed"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);