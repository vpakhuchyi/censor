"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[321],{7746:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"type-handling/complex-types","title":"Complex Types","description":"Censor provides robust support for complex Go types. This guide details how each complex type is handled by Censor.","source":"@site/docs/type-handling/complex-types.md","sourceDirName":"type-handling","slug":"/type-handling/complex-types","permalink":"/censor/type-handling/complex-types","draft":false,"unlisted":false,"editUrl":"https://github.com/vpakhuchyi/censor-doc/tree/main/docs/type-handling/complex-types.md","tags":[],"version":"current","lastUpdatedBy":"Viktor","lastUpdatedAt":1744745893000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docs","previous":{"title":"Basic Types","permalink":"/censor/type-handling/basic-types"},"next":{"title":"Special Types","permalink":"/censor/type-handling/special-types"}}');var r=s(4848),i=s(8453);const a={sidebar_position:2},l="Complex Types",o={},c=[{value:"Structs",id:"structs",level:2},{value:"Nested Structs",id:"nested-structs",level:3},{value:"Embedded Structs",id:"embedded-structs",level:3},{value:"Maps",id:"maps",level:2},{value:"Basic Maps",id:"basic-maps",level:3},{value:"Nested Maps",id:"nested-maps",level:3},{value:"Maps with Complex Keys",id:"maps-with-complex-keys",level:3},{value:"Slices and Arrays",id:"slices-and-arrays",level:2},{value:"Basic Slices",id:"basic-slices",level:3},{value:"Slices of Structs",id:"slices-of-structs",level:3},{value:"Multidimensional Slices",id:"multidimensional-slices",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"complex-types",children:"Complex Types"})}),"\n",(0,r.jsx)(n.p,{children:"Censor provides robust support for complex Go types. This guide details how each complex type is handled by Censor."}),"\n",(0,r.jsx)(n.h2,{id:"structs",children:"Structs"}),"\n",(0,r.jsx)(n.p,{children:"Structs are processed recursively, with each field being processed according to its type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'type Address struct {\n    Street  string\n    City    string\n    ZipCode string\n}\n\ntype User struct {\n    ID      string  `censor:"display"`\n    Email   string\n    Address Address\n}\n\nuser := User{\n    ID:    "123",\n    Email: "user@example.com",\n    Address: Address{\n        Street:  "123 Main St",\n        City:    "New York",\n        ZipCode: "10001",\n    },\n}\n\n// TEXT output: {ID:123 Email:[CENSORED] Address:{Street:[CENSORED] City:[CENSORED] ZipCode:[CENSORED]}}.\n// JSON output: {"ID":"123","Email":"[CENSORED]","Address":{"Street":"[CENSORED]","City":"[CENSORED]","ZipCode":"[CENSORED]"}}.\n'})}),"\n",(0,r.jsx)(n.h3,{id:"nested-structs",children:"Nested Structs"}),"\n",(0,r.jsx)(n.p,{children:"Censor processes nested structs to any depth:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'type Contact struct {\n    Email    string\n    Phone    string\n}\n\ntype Address struct {\n    Street  string\n    City    string\n    ZipCode string\n}\n\ntype User struct {\n    ID      string  `censor:"display"`\n    Contact Contact\n    Address Address\n}\n\nuser := User{\n    ID: "123",\n    Contact: Contact{\n        Email: "user@example.com",\n        Phone: "555-1234",\n    },\n    Address: Address{\n        Street:  "123 Main St",\n        City:    "New York",\n        ZipCode: "10001",\n    },\n}\n\n// TEXT output: {ID:123 Contact:{Email:[CENSORED] Phone:[CENSORED]} Address:{Street:[CENSORED] City:[CENSORED] ZipCode:[CENSORED]}}.\n// JSON output: {"ID":"123","Contact":{"Email":"[CENSORED]","Phone":"[CENSORED]"},"Address":{"Street":"[CENSORED]","City":"[CENSORED]","ZipCode":"[CENSORED]"}}.\n'})}),"\n",(0,r.jsx)(n.h3,{id:"embedded-structs",children:"Embedded Structs"}),"\n",(0,r.jsx)(n.p,{children:"Censor handles embedded structs, processing all fields:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'type Person struct {\n    Name  string\n    Email string\n}\n\ntype Employee struct {\n    Person\n    ID    string `censor:"display"`\n    Title string\n}\n\nemployee := Employee{\n    Person: Person{\n        Name:  "John Doe",\n        Email: "john@example.com",\n    },\n    ID:    "emp-123",\n    Title: "Software Engineer",\n}\n\n// TEXT output: {Person:{Name:[CENSORED] Email:[CENSORED]} ID:emp-123 Title:[CENSORED]}.\n// JSON output: {"Name":"[CENSORED]","Email":"[CENSORED]","ID":"emp-123","Title":"[CENSORED]"}.\n'})}),"\n",(0,r.jsx)(n.h2,{id:"maps",children:"Maps"}),"\n",(0,r.jsx)(n.p,{children:"Maps are processed recursively, with both keys and values being processed according to their types."}),"\n",(0,r.jsx)(n.h3,{id:"basic-maps",children:"Basic Maps"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'user := map[string]string{\n    "id":       "123",\n    "email":    "user@example.com",\n    "password": "secret123",\n}\n\n// TEXT output: map[id:123 email:[CENSORED] password:[CENSORED]].\n// JSON output: {"id":"123","email":"[CENSORED]","password":"[CENSORED]"}.\n'})}),"\n",(0,r.jsx)(n.p,{children:"You can configure the map key handling:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Create a Censor instance with custom key handling.\n// Return true to display the key, false to mask it.\n// Processing with custom map key handler.\nc := censor.New(\n    censor.WithMapKeyHandler(func(key string) bool {\n        // Return true to display the key, false to mask it.\n        return key == "id"\n    }),\n)\n\nuser := map[string]string{\n    "id":       "123",\n    "email":    "user@example.com",\n    "password": "secret123",\n}\n\n// Processing with custom map key handler.\nmasked := c.Process(user)\n// TEXT output: map[id:123 [CENSORED]:[CENSORED] [CENSORED]:[CENSORED]].\n// JSON output: {"id":"123","[CENSORED]":"[CENSORED]","[CENSORED]":"[CENSORED]"}.\n'})}),"\n",(0,r.jsx)(n.h3,{id:"nested-maps",children:"Nested Maps"}),"\n",(0,r.jsx)(n.p,{children:"Censor processes nested maps to any depth:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'userData := map[string]interface{}{\n    "id": "123",\n    "contact": map[string]string{\n        "email": "user@example.com",\n        "phone": "555-1234",\n    },\n    "address": map[string]string{\n        "street":  "123 Main St",\n        "city":    "New York",\n        "zipCode": "10001",\n    },\n}\n\n// TEXT output: map[id:123 contact:map[email:[CENSORED] phone:[CENSORED]] address:map[street:[CENSORED] city:[CENSORED] zipCode:[CENSORED]]].\n// JSON output: {"id":"123","contact":{"email":"[CENSORED]","phone":"[CENSORED]"},"address":{"street":"[CENSORED]","city":"[CENSORED]","zipCode":"[CENSORED]"}}.\n'})}),"\n",(0,r.jsx)(n.h3,{id:"maps-with-complex-keys",children:"Maps with Complex Keys"}),"\n",(0,r.jsx)(n.p,{children:"Censor handles maps with non-string keys:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Map with integer keys.\nuserScores := map[int]int{\n    1: 100,\n    2: 200,\n    3: 300,\n}\n\n// TEXT output: map[1:100 2:200 3:300].\n// JSON output: {"1":100,"2":200,"3":300}.\n\n// Map with struct keys.\ntype UserID struct {\n    ID   string\n    Type string\n}\n\nuserMap := map[UserID]string{\n    {ID: "123", Type: "customer"}: "John",\n    {ID: "456", Type: "employee"}: "Jane",\n}\n\n// TEXT output: map[{ID:[CENSORED] Type:[CENSORED]}:[CENSORED] {ID:[CENSORED] Type:[CENSORED]}:[CENSORED]].\n// JSON output: {"{\\"ID\\":\\"[CENSORED]\\",\\"Type\\":\\"[CENSORED]\\"}":"[CENSORED]","{\\"ID\\":\\"[CENSORED]\\",\\"Type\\":\\"[CENSORED]\\"}":"[CENSORED]"}.\n'})}),"\n",(0,r.jsx)(n.h2,{id:"slices-and-arrays",children:"Slices and Arrays"}),"\n",(0,r.jsx)(n.p,{children:"Slices and arrays are processed by iterating over each element and processing it according to its type."}),"\n",(0,r.jsx)(n.h3,{id:"basic-slices",children:"Basic Slices"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Slice of strings.\nemails := []string{\n    "user1@example.com",\n    "user2@example.com",\n    "user3@example.com",\n}\n\n// TEXT output: [[CENSORED] [CENSORED] [CENSORED]].\n// JSON output: ["[CENSORED]","[CENSORED]","[CENSORED]"].\n\n// Slice of integers.\nscores := []int{100, 200, 300}\n\n// TEXT output: [100 200 300].\n// JSON output: [100,200,300].\n'})}),"\n",(0,r.jsx)(n.h3,{id:"slices-of-structs",children:"Slices of Structs"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'type User struct {\n    ID    string `censor:"display"`\n    Email string\n}\n\nusers := []User{\n    {ID: "1", Email: "user1@example.com"},\n    {ID: "2", Email: "user2@example.com"},\n    {ID: "3", Email: "user3@example.com"},\n}\n\n// TEXT output: [{ID:1 Email:[CENSORED]} {ID:2 Email:[CENSORED]} {ID:3 Email:[CENSORED]}].\n// JSON output: [{"ID":"1","Email":"[CENSORED]"},{"ID":"2","Email":"[CENSORED]"},{"ID":"3","Email":"[CENSORED]"}].\n'})}),"\n",(0,r.jsx)(n.h3,{id:"multidimensional-slices",children:"Multidimensional Slices"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// 2D slice of strings.\nmatrix := [][]string{\n    {"user1@example.com", "password1"},\n    {"user2@example.com", "password2"},\n    {"user3@example.com", "password3"},\n}\n\n// TEXT output: [[CENSORED] [CENSORED]] [[CENSORED] [CENSORED]] [[CENSORED] [CENSORED]]\n// JSON output: [["[CENSORED]","[CENSORED]"],["[CENSORED]","[CENSORED]"],["[CENSORED]","[CENSORED]"]]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"arrays",children:"Arrays"}),"\n",(0,r.jsx)(n.p,{children:"Arrays are processed the same way as slices:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Array of strings\nvar emails [3]string\nemails[0] = "user1@example.com"\nemails[1] = "user2@example.com"\nemails[2] = "user3@example.com"\n\n// TEXT output: [[CENSORED] [CENSORED] [CENSORED]]\n// JSON output: ["[CENSORED]","[CENSORED]","[CENSORED]"]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example showing how Censor handles various complex types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "github.com/vpakhuchyi/censor"\n)\n\nfunc main() {\n    // Create a Censor instance\n    c := censor.New()\n\n    // Define types\n    type Address struct {\n        Street  string\n        City    string\n        ZipCode string\n    }\n\n    type Contact struct {\n        Email string\n        Phone string\n    }\n\n    type User struct {\n        ID       string         `censor:"display"`\n        Name     string\n        Contact  Contact\n        Address  Address\n        Tags     []string\n        Metadata map[string]string\n    }\n\n    // Create user data\n    user := User{\n        ID:   "123",\n        Name: "John Doe",\n        Contact: Contact{\n            Email: "john@example.com",\n            Phone: "555-1234",\n        },\n        Address: Address{\n            Street:  "123 Main St",\n            City:    "New York",\n            ZipCode: "10001",\n        },\n        Tags: []string{"customer", "premium", "active"},\n        Metadata: map[string]string{\n            "last_login": "2023-01-01",\n            "api_key":    "sk_live_123456789",\n        },\n    }\n\n    // Process the data\n    masked := c.Process(user)\n    fmt.Printf("%+v\\n", masked)\n    // TEXT output: {ID:123 Name:[CENSORED] Contact:{Email:[CENSORED] Phone:[CENSORED]} Address:{Street:[CENSORED] City:[CENSORED] ZipCode:[CENSORED]} Tags:[[CENSORED] [CENSORED] [CENSORED]] Metadata:map[api_key:[CENSORED] last_login:[CENSORED]]}\n    // JSON output: {"ID":"123","Name":"[CENSORED]","Contact":{"Email":"[CENSORED]","Phone":"[CENSORED]"},"Address":{"Street":"[CENSORED]","City":"[CENSORED]","ZipCode":"[CENSORED]"},"Tags":["[CENSORED]","[CENSORED]","[CENSORED]"],"Metadata":{"api_key":"[CENSORED]","last_login":"[CENSORED]"}}\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Learn about ",(0,r.jsx)(n.a,{href:"basic-types",children:"Basic Types"})]}),"\n",(0,r.jsxs)(n.li,{children:["Check out ",(0,r.jsx)(n.a,{href:"special-types",children:"Special Types"})]}),"\n",(0,r.jsxs)(n.li,{children:["See ",(0,r.jsx)(n.a,{href:"format-specific",children:"Format-Specific"})," handling"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var t=s(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);