"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[731],{3423:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>t,default:()=>a,frontMatter:()=>l,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"types","title":"Types Support","description":"This guide details which Go types are supported by Censor and how they are handled.","source":"@site/docs/types.md","sourceDirName":".","slug":"/types","permalink":"/censor/types","draft":false,"unlisted":false,"editUrl":"https://github.com/vpakhuchyi/censor/tree/main/documentation/docs/types.md","tags":[],"version":"current","lastUpdatedBy":"Viktor","lastUpdatedAt":1743858422000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4}}');var d=n(4848),i=n(8453);const l={sidebar_position:4},t="Types Support",c={},h=[{value:"Supported Types",id:"supported-types",level:2},{value:"Basic Types",id:"basic-types",level:3},{value:"Composite Types",id:"composite-types",level:3},{value:"Special Types",id:"special-types",level:3},{value:"Detailed Behavior",id:"detailed-behavior",level:2},{value:"Structs",id:"structs",level:3},{value:"Maps",id:"maps",level:3},{value:"Slices and Arrays",id:"slices-and-arrays",level:3},{value:"Pointers",id:"pointers",level:3},{value:"Interfaces",id:"interfaces",level:3},{value:"Unsupported Types",id:"unsupported-types",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2}];function o(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(s.header,{children:(0,d.jsx)(s.h1,{id:"types-support",children:"Types Support"})}),"\n",(0,d.jsx)(s.p,{children:"This guide details which Go types are supported by Censor and how they are handled."}),"\n",(0,d.jsx)(s.h2,{id:"supported-types",children:"Supported Types"}),"\n",(0,d.jsx)(s.h3,{id:"basic-types",children:"Basic Types"}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Type"}),(0,d.jsx)(s.th,{children:"Support"}),(0,d.jsx)(s.th,{children:"Notes"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"string"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Full support with pattern matching"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"bool"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Values displayed as-is"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"int"}),"/",(0,d.jsx)(s.code,{children:"int8"}),"/",(0,d.jsx)(s.code,{children:"int16"}),"/",(0,d.jsx)(s.code,{children:"int32"}),"/",(0,d.jsx)(s.code,{children:"int64"})]}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Values displayed as-is"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"uint"}),"/",(0,d.jsx)(s.code,{children:"uint8"}),"/",(0,d.jsx)(s.code,{children:"uint16"}),"/",(0,d.jsx)(s.code,{children:"uint32"}),"/",(0,d.jsx)(s.code,{children:"uint64"})]}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Values displayed as-is"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"float32"}),"/",(0,d.jsx)(s.code,{children:"float64"})]}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Values displayed as-is"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"complex64"}),"/",(0,d.jsx)(s.code,{children:"complex128"})]}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Values displayed as-is"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"byte"})," (uint8)"]}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Values displayed as-is"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsxs)(s.td,{children:[(0,d.jsx)(s.code,{children:"rune"})," (int32)"]}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Values displayed as-is"})]})]})]}),"\n",(0,d.jsx)(s.h3,{id:"composite-types",children:"Composite Types"}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Type"}),(0,d.jsx)(s.th,{children:"Support"}),(0,d.jsx)(s.th,{children:"Notes"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"struct"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Full support with field tags"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"map"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Both keys and values processed"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"slice"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"All elements processed"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"array"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"All elements processed"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"pointer"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Underlying value processed"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"interface"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Concrete type processed"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"channel"})}),(0,d.jsx)(s.td,{children:"\u274c"}),(0,d.jsx)(s.td,{children:"Not supported"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"func"})}),(0,d.jsx)(s.td,{children:"\u274c"}),(0,d.jsx)(s.td,{children:"Not supported"})]})]})]}),"\n",(0,d.jsx)(s.h3,{id:"special-types",children:"Special Types"}),"\n",(0,d.jsxs)(s.table,{children:[(0,d.jsx)(s.thead,{children:(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.th,{children:"Type"}),(0,d.jsx)(s.th,{children:"Support"}),(0,d.jsx)(s.th,{children:"Notes"})]})}),(0,d.jsxs)(s.tbody,{children:[(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"time.Time"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Processed as string"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"encoding.TextMarshaler"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Custom text representation"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"error"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:"Error message processed"})]}),(0,d.jsxs)(s.tr,{children:[(0,d.jsx)(s.td,{children:(0,d.jsx)(s.code,{children:"nil"})}),(0,d.jsx)(s.td,{children:"\u2705"}),(0,d.jsx)(s.td,{children:'Displayed as "nil"'})]})]})]}),"\n",(0,d.jsx)(s.h2,{id:"detailed-behavior",children:"Detailed Behavior"}),"\n",(0,d.jsx)(s.h3,{id:"structs",children:"Structs"}),"\n",(0,d.jsx)(s.p,{children:"Structs are processed field by field:"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-go",children:'type User struct {\n    ID       string `censor:"display"` // Will be visible\n    Password string                    // Will be masked\n    private  string                    // Ignored (unexported)\n}\n'})}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Notes"}),":"]}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:["Use ",(0,d.jsx)(s.code,{children:'censor:"display"'})," tag to show field value"]}),"\n",(0,d.jsx)(s.li,{children:"Unexported fields are ignored"}),"\n",(0,d.jsx)(s.li,{children:"Embedded structs are processed recursively"}),"\n"]}),"\n",(0,d.jsx)(s.h3,{id:"maps",children:"Maps"}),"\n",(0,d.jsx)(s.p,{children:"Maps are processed recursively for both keys and values:"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-go",children:'// Simple map\nmap[string]string{"password": "secret"} \n// Output: map[password: [CENSORED]]\n\n// Complex map\nmap[User][]string{\n    {ID: "123"}: {"data1", "data2"},\n}\n// Output: map[{ID: 123, ...}: [[CENSORED], [CENSORED]]]\n'})}),"\n",(0,d.jsxs)(s.p,{children:[(0,d.jsx)(s.strong,{children:"Notes"}),":"]}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:"Map type can be displayed with configuration"}),"\n",(0,d.jsx)(s.li,{children:"Keys and values processed independently"}),"\n",(0,d.jsx)(s.li,{children:"Nested maps handled recursively"}),"\n"]}),"\n",(0,d.jsx)(s.h3,{id:"slices-and-arrays",children:"Slices and Arrays"}),"\n",(0,d.jsx)(s.p,{children:"Elements are processed according to their type:"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-go",children:'// String slice\n[]string{"password1", "password2"}\n// Output: [[CENSORED], [CENSORED]]\n\n// Mixed slice\n[]interface{}{1, "secret", true}\n// Output: [1, [CENSORED], true]\n'})}),"\n",(0,d.jsx)(s.h3,{id:"pointers",children:"Pointers"}),"\n",(0,d.jsx)(s.p,{children:"Pointers are dereferenced and their values processed:"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-go",children:'s := "secret"\nptr := &s\n// Output: [CENSORED]\n\nvar nilPtr *string\n// Output: nil\n'})}),"\n",(0,d.jsx)(s.h3,{id:"interfaces",children:"Interfaces"}),"\n",(0,d.jsx)(s.p,{children:"Interface values are processed based on their concrete type:"}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-go",children:'var data interface{} = "sensitive"\n// Output: [CENSORED]\n\nvar data interface{} = 42\n// Output: 42\n'})}),"\n",(0,d.jsx)(s.h2,{id:"unsupported-types",children:"Unsupported Types"}),"\n",(0,d.jsx)(s.p,{children:"The following types are not supported by Censor:"}),"\n",(0,d.jsxs)(s.ol,{children:["\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Channels"})}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-go",children:"ch := make(chan int)\n// Will not be processed\n"})}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Functions"})}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-go",children:"fn := func() {}\n// Will not be processed\n"})}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Unsafe Pointer"})}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{className:"language-go",children:"var ptr unsafe.Pointer\n// Will not be processed\n"})}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,d.jsxs)(s.ol,{children:["\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Type Safety"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:"Use appropriate types for your data"}),"\n",(0,d.jsxs)(s.li,{children:["Avoid interface"," unless necessary"]}),"\n",(0,d.jsx)(s.li,{children:"Use struct tags consistently"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Performance"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:"Consider type complexity when processing large data structures"}),"\n",(0,d.jsx)(s.li,{children:"Use pointers for large structs"}),"\n",(0,d.jsx)(s.li,{children:"Avoid unnecessary type conversions"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Error Handling"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:"Check for unsupported types before processing"}),"\n",(0,d.jsx)(s.li,{children:"Handle nil values appropriately"}),"\n",(0,d.jsx)(s.li,{children:"Use appropriate error logging"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Custom Types"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsxs)(s.li,{children:["Implement ",(0,d.jsx)(s.code,{children:"encoding.TextMarshaler"})," for custom string representation"]}),"\n",(0,d.jsx)(s.li,{children:"Use struct tags for custom type fields"}),"\n",(0,d.jsx)(s.li,{children:"Document type-specific behavior"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(s.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,d.jsxs)(s.ol,{children:["\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Unexported Fields"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:"Unexported struct fields are always ignored"}),"\n",(0,d.jsx)(s.li,{children:"Use exported fields for data that needs processing"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Interface Type Assertions"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:"Be careful with type assertions in interface values"}),"\n",(0,d.jsx)(s.li,{children:"Handle unknown types appropriately"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Circular References"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:"Avoid circular references in data structures"}),"\n",(0,d.jsx)(s.li,{children:"Use pointers carefully to prevent infinite recursion"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(s.li,{children:["\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.strong,{children:"Complex Types"})}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:"Be aware of performance impact with deeply nested structures"}),"\n",(0,d.jsx)(s.li,{children:"Consider flattening complex data structures when possible"}),"\n"]}),"\n"]}),"\n"]})]})}function a(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,d.jsx)(s,{...e,children:(0,d.jsx)(o,{...e})}):o(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>t});var r=n(6540);const d={},i=r.createContext(d);function l(e){const s=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:l(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);